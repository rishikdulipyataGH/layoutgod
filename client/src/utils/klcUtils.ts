// KLC (Keyboard Layout Creator) Format Utilities
// KLC is Microsoft's keyboard layout creation format

export interface KlcKey {
  scanCode: string;
  virtualKey: string;
  cap: string;
  characters: string[];
  shiftState?: string;
  ctrl?: string;
  altGr?: string;
}

export interface KlcLayout {
  name: string;
  description: string;
  company: string;
  localeName: string;
  localeId: string;
  version: string;
  keys: KlcKey[];
  deadKeys?: string[];
  ligatures?: string[];
  keyNames?: { [key: string]: string };
}

// Scan code to position mapping for standard US QWERTY layout
const SCAN_CODE_MAP: { [key: string]: string } = {
  '10': 'q', '11': 'w', '12': 'e', '13': 'r', '14': 't', '15': 'y', '16': 'u', '17': 'i', '18': 'o', '19': 'p',
  '1e': 'a', '1f': 's', '20': 'd', '21': 'f', '22': 'g', '23': 'h', '24': 'j', '25': 'k', '26': 'l', '27': ';',
  '2c': 'z', '2d': 'x', '2e': 'c', '2f': 'v', '30': 'b', '31': 'n', '32': 'm', '33': ',', '34': '.', '35': '/'
};

const POSITION_TO_SCAN_CODE: { [key: string]: string } = Object.fromEntries(
  Object.entries(SCAN_CODE_MAP).map(([scan, pos]) => [pos, scan])
);

// Virtual key codes for common keys
const VIRTUAL_KEY_MAP: { [key: string]: string } = {
  'q': 'Q', 'w': 'W', 'e': 'E', 'r': 'R', 't': 'T', 'y': 'Y', 'u': 'U', 'i': 'I', 'o': 'O', 'p': 'P',
  'a': 'A', 's': 'S', 'd': 'D', 'f': 'F', 'g': 'G', 'h': 'H', 'j': 'J', 'k': 'K', 'l': 'L', ';': 'OEM_1',
  'z': 'Z', 'x': 'X', 'c': 'C', 'v': 'V', 'b': 'B', 'n': 'N', 'm': 'M', ',': 'OEM_COMMA', '.': 'OEM_PERIOD', '/': 'OEM_2'
};

/**
 * Parse a KLC file content string into a KlcLayout object
 */
export function parseKlcFile(content: string): KlcLayout {
  const lines = content.split('\n').map(line => line.trim());
  
  const layout: KlcLayout = {
    name: '',
    description: '',
    company: '',
    localeName: '',
    localeId: '',
    version: '1.0',
    keys: []
  };
  
  let inLayoutSection = false;
  
  for (const line of lines) {
    if (line.startsWith('KBD\t')) {
      layout.name = line.split('\t')[1] || '';
    } else if (line.startsWith('COPYRIGHT\t')) {
      layout.company = line.split('\t')[1] || '';
    } else if (line.startsWith('DESCRIPTIONS')) {
      layout.description = line.split('\t')[1] || '';
    } else if (line.startsWith('LOCALENAME\t')) {
      layout.localeName = line.split('\t')[1] || '';
    } else if (line.startsWith('LOCALEID\t')) {
      layout.localeId = line.split('\t')[1] || '';
    } else if (line.startsWith('VERSION\t')) {
      layout.version = line.split('\t')[1] || '';
    } else if (line === 'LAYOUT') {
      inLayoutSection = true;
    } else if (inLayoutSection && line.includes('\t')) {
      const parts = line.split('\t');
      if (parts.length >= 4) {
        const scanCode = parts[0];
        const virtualKey = parts[1];
        const cap = parts[2];
        const characters = parts.slice(3);
        
        layout.keys.push({
          scanCode,
          virtualKey,
          cap,
          characters
        });
      }
    } else if (line.startsWith('LIGATURE') || line.startsWith('KEYNAME') || line.startsWith('DEADKEY')) {
      // End of layout section
      inLayoutSection = false;
    }
  }
  
  return layout;
}

/**
 * Generate KLC file content from a layout object
 */
export function generateKlcFile(layoutName: string, layoutData: Record<string, string>, description: string = ''): string {
  const timestamp = new Date().toISOString().split('T')[0];
  
  let klcContent = `KBD\t${layoutName.replace(/[^a-zA-Z0-9]/g, '')}\t"${layoutName}"\n\n`;
  klcContent += `COPYRIGHT\t"Generated by Keyboard Layout Analyzer"\n\n`;
  klcContent += `COMPANY\t"Keyboard Layout Analyzer"\n\n`;
  klcContent += `LOCALENAME\t"en-US"\n\n`;
  klcContent += `LOCALEID\t"00000409"\n\n`;
  klcContent += `VERSION\t1.0\n\n`;
  
  if (description) {
    klcContent += `DESCRIPTIONS\n`;
    klcContent += `0409\t${description}\n\n`;
  }
  
  klcContent += `LAYOUT\t\t;an extra '\t' here will cause a build error\n\n`;
  klcContent += `//SC\tVK_\t\tCap\tCh0\tCh1\tCh2\tCh3\tCh4\tCh5\tCh6\tCh7\n`;
  klcContent += `//--\t---\t\t---\t---\t---\t---\t---\t---\t---\t---\t---\n\n`;
  
  // Generate key mappings
  Object.entries(layoutData).forEach(([position, character]) => {
    const scanCode = POSITION_TO_SCAN_CODE[position];
    const virtualKey = VIRTUAL_KEY_MAP[position];
    
    if (scanCode && virtualKey) {
      const upperChar = character.toUpperCase();
      const lowerChar = character.toLowerCase();
      
      klcContent += `${scanCode}\t${virtualKey}\t\t0\t${lowerChar}\t${upperChar}\t\t\t\t\t\t\n`;
    }
  });
  
  klcContent += `\nKEYNAME\n\n`;
  klcContent += `01\tEsc\n`;
  klcContent += `0e\tBackspace\n`;
  klcContent += `0f\tTab\n`;
  klcContent += `1c\tEnter\n`;
  klcContent += `1d\tCtrl\n`;
  klcContent += `2a\tShift\n`;
  klcContent += `36\tRight Shift\n`;
  klcContent += `38\tAlt\n`;
  klcContent += `39\tSpace\n`;
  klcContent += `3a\tCaps Lock\n`;
  
  klcContent += `\nKEYNAME_EXT\n\n`;
  klcContent += `1c\tNum Enter\n`;
  klcContent += `1d\tRight Ctrl\n`;
  klcContent += `38\tRight Alt\n`;
  
  klcContent += `\nKEYNAME_DEAD\n\n`;
  
  klcContent += `\nDESCRIPTIONS\n\n`;
  klcContent += `0409\t${layoutName}\n`;
  
  klcContent += `\nLANGUAGENAMES\n\n`;
  klcContent += `0409\tEnglish (United States)\n`;
  
  klcContent += `\nENDKBD\n`;
  
  return klcContent;
}

/**
 * Convert KLC layout to simple key mapping
 */
export function klcToKeyMapping(klcLayout: KlcLayout): Record<string, string> {
  const keyMapping: Record<string, string> = {};
  
  klcLayout.keys.forEach(key => {
    const position = SCAN_CODE_MAP[key.scanCode];
    if (position && key.characters.length > 0) {
      // Use the first character (unshifted state)
      keyMapping[position] = key.characters[0] || position;
    }
  });
  
  return keyMapping;
}

/**
 * Generate a text-based visual representation of the layout
 */
export function generateTextVisual(layoutData: Record<string, string>): string {
  const rows = [
    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';'],
    ['z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/']
  ];
  
  let visual = '';
  
  rows.forEach((row, rowIndex) => {
    // Add appropriate spacing for each row
    if (rowIndex === 1) visual += ' ';  // Home row offset
    if (rowIndex === 2) visual += '  '; // Bottom row offset
    
    row.forEach((key, keyIndex) => {
      const char = layoutData[key] || key;
      visual += char.padEnd(2, ' ');
      if (keyIndex < row.length - 1) visual += ' ';
    });
    
    visual += '\n';
  });
  
  return visual.trim();
}

/**
 * Parse text visual format back to key mapping
 */
export function parseTextVisual(textVisual: string): Record<string, string> {
  const lines = textVisual.split('\n');
  const keyMapping: Record<string, string> = {};
  
  const rows = [
    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';'],
    ['z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/']
  ];
  
  lines.forEach((line, rowIndex) => {
    if (rowIndex >= rows.length) return;
    
    // Remove leading spaces based on row offset
    let trimmedLine = line;
    if (rowIndex === 1 && line.startsWith(' ')) trimmedLine = line.substring(1);
    if (rowIndex === 2 && line.startsWith('  ')) trimmedLine = line.substring(2);
    
    const chars = trimmedLine.split(' ').filter(char => char.length > 0);
    
    chars.forEach((char, charIndex) => {
      if (charIndex < rows[rowIndex].length) {
        const position = rows[rowIndex][charIndex];
        keyMapping[position] = char.trim() || position;
      }
    });
  });
  
  return keyMapping;
}

/**
 * Validate if a file content looks like a KLC file
 */
export function isValidKlcContent(content: string): boolean {
  return content.includes('KBD\t') && 
         content.includes('LAYOUT') && 
         (content.includes('LOCALENAME') || content.includes('LOCALEID'));
}

/**
 * Validate if text content looks like a visual layout
 */
export function isValidTextVisual(content: string): boolean {
  const lines = content.split('\n').filter(line => line.trim().length > 0);
  return lines.length >= 2 && lines.length <= 4 && // Should have 2-4 rows
         lines.some(line => line.split(/\s+/).length >= 8); // At least one row should have 8+ characters
}
